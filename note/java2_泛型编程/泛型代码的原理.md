### 泛型代码和虚拟机
虚拟机**没有泛型类型对象**————所有对象都属于普通类。

#### 原始类型
无论何时定义一个泛型类型，都自动提供一个相应的**原始类型**。
真正在虚拟机运行的对象是原始类型的对象。泛型的实现实质是编译器对原始类型的参数自动检查以及返回值自动插入强制转换来实现的。

原始类型：
+ 原始类型名：即删去类型参数后的泛型类型名
+ 檫除类型变量：泛型类的类型变量被檫除，**然后替换成限定类型**(无限顶类型则替换成Object)
+ 原始类型用**第一个限定的类型**来替换类型变量。
    + 切换限定的时候，编译器在必要的时候插入类型转换。
    + 所以为了提高效率，应该将标价接口放在限定列表最后

#### 翻译泛型表达式
当程序调用泛型方法时，如果檫除了返回类型，那么编译器就会自动插入强制类型转换。
实际上编译器将方法调用翻译成这样子的两条指令
1. 调用原始方法
2. 对返回值强制类型转换。


#### 翻译泛型方法
泛型方法中也会檫除类型。
泛型方法在檫除类型后可能会**发生继承问题**————即原本是同签名的继承方法，因为檫除类型后变成了不同签名的普通方法。
```java
//泛型类与继承问题
class Pair<T>{
    public void setSecond(T t){}
}
class DataInterval extends Pair<LocalData>{
    public void setSecond(LocalData second){} //这个方法显然是要继承Pair.setSecond(T)
}
//但是檫除类型后，实际的继承的方法是
class Pair{
    public void setSecond(Object t){}
}
class DataInterval extends Pair<LocalData>{
    public void setSecond(Object second){}  //这个方法才是实际继承的方法
    public void setSecond(LocalData sencond){} //檫除类型后变成了普通的方法。
}
```

**编译器通过合成桥方法解决上述继承问题**
```
public void setSecond(Object second)
{
    setSecond((LocaldData) second);//即自动覆盖实际继承的方法，并在覆盖方法中调用期望继承的方法，这样子就能保持多态性了。
}
```
**桥方法签名包括返回类型**
对于一些无参数方法，显然桥方法和期望继承的方法的参数类型一样，也就是说方法签名是一样。所以**java代码不能编写两个签名相同的方法**。
但是实际上，在虚拟机中，用参数类型和返回类型唯一确定一个方法。
所以编译可能产生两个**仅返回类型不同的字节码代码**，来区分这两个方法。
例如以下方法
```java
class DataInterval extends Pari<LocalData>
    public LocalData getSecond(){ ... };
    //显然桥方法如下
    //public Object getSecond(){ return (LocalData)getSecond()}
    //显然不能在java代码中编写这样的方法
    //但是编译器可以生成仅返回类型不同的字节码。

```

#### 原始类型与泛型类型
当将泛型类型对象传入一个接受原始类型的方法时候，会得到警告。
因为需要确定该方法是否能正确地操作泛型类型的类型变量。
比如，可能该方法默认原始类型的域是A,B类型。从而对其进行处理，然而泛型类的类型变量可能D，C。
而实际上是不能把对A,B的操作应用于D,C。

当把一个原始类型对象赋给泛型类型对象，也会得到警告。
因为无法确定原始类型的域是否一一对应参数化的类型变量

总之，在原始类型和泛型类型相互赋值的时候，要**确定类型变量一一对应可用**，否则可能会发生不可预料的错误。1
