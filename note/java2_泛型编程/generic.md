### 范型
范型程序设计(generic programming)意味着编写的代码可以被很多不同类型的对象所重用。
可以将范型类看作普通类的工厂，例如
```java
calss ArrayList<T>{
    //范型类，使用类型变量来只是某个类型，
}

//当给范型类的类型变量传入不同的类型参数时候，就相当于产生了一个使用该类型参数指定的类型的类
ArrayList<String> list1 = new ArrayList<>();
ArrayList<Integer> list2 = new ArrayList<>();
...
ArrayList<Object> listn = new ArrayList<>();
//相当于为每个类型参数生成了一个用于其类型的数组链表
```

类型变量常用**大写**表示，`E`表示集合的元素类型，`K,V`分别表示表的关键字和值的类型，`T,U,S`常用来表示任意类型。

#### 类型参数的好处
在增加范型类之间，范型程序设计是通过继承来实现。这样子有两个问题。
+ 传入参数没有错误检查。
+ 读取返回值需要强制类型转换

而使用范型类，编译器就可以根据类型参数来
+ 自动检查参数，
+ 以及自动插入强制类型转换。

总而言之，类型参数使得程序有更好的可读性和安全性。

#### 定义范型类
一个范型类是具有**一个或多个类型变量**的类。
+ 类型变量用`<>`括起来，多个类型变量之间用**逗号隔开**，**贴在类名之后**。
+ 类定义中的类型变量指定方法的**返回类型**以及**域**和**局部变量**的类型。
+ 给不同的类型变量传入不同的类型参数就可以指定不同的类型。
```java
class pair<T,U>{
    T t;
    U u; //用来指定域的类型

    U method()  //用来指定返回值的类型
    {
        T t1 = ...; //指定局部变量的类型
    }
}

```

#### 定义泛型方法
可以定义一个**带类型参数的方法**，这个方法不是通过泛型类的类型变量来指定类型，而是**方法自己指定类型参数**。
泛型方法可以在普通类中定义。当然啦也可以在泛型类中定义，不过这样做意义不大。

定义泛型方法：用尖括号`<>`括起类型变量，多个类型变量之间用逗号隔开，**放在修饰符之后，返回值之前**，即可定义泛型方法。
泛型方法的类型变量指定方法的**返回类型**以及**局部变量**的类型。
调用泛型方法：在**方法名前的尖括号填入具体的类型**。大多书情况，可以省略类型参数，因为编译器可以推断类型，但是也会发生错误的时候，所以省略要近摄关。
```java
class GenericMethod{
    public static <T> T getT()  //修饰符后，返回值前定义类型变量，从而定义泛型方法
    {
        T t = ... ;//指定局部变量类型
        ...
        return t;   //指定返回类型
    }
}


String str = GenericMethod.<String>getT();

String str2 = GenericMethod.getT(); //由变量str2类型推断出类型，故可以省略类型参数

```

#### 类型变量的限定
有时，类和方法需要对类型变量加以约束。
+ 可以对类型变量设置限定。T和绑定类型**可以是类和接口**。
    + 子类型限定，语法：`T extends TypeName` 表示T应该是绑定类型的子类型。
    + 注意：类型变量只有子类型限定。
+ 可以有多个限定，限定类型之间用`&`分隔。
    + 如果用**类做限定类型**，则类的类型必须是**限定列表的第一个**。
```java
class pair <T extends Comparable, U extends Cloneable>
{
}

	//类型变量限定
	public static <S extends Comparable<?>> S getAllS(S s)
	{
		return s;
	}
	//类限定必须作为限定列表的第一个
	public static <T,U, S extends Generic<T,U> & Comparable<?> > S getAllSs(S s) {
								  //限定列表................//
		return s;
	}
	


```


