### 通配符类型
在实例化一个泛型类时，一旦传入类型参数，类型就固定了。这样子会造成很多不方便。
而通配符类型允许类型参数变化。如下所示
```java
Pair<Integer> pi ; // pi只能接受Pair<Integer>

Pair<?> pe; // pe 可以接受任何参数化pair类型，如Pair<Integer> Pair<String>
Pari<? extends Employee> pem; // pem 可以接受Employee继承层次的所有类型实例化的泛型类
```

#### 通配符限定
与类型变量的限定类似。
通配符也有限定，限定通配符允许变换的类型的范围
+ 子类型限定，语法`? extends Type` 限定为Type的所有子类以及自己
+ 超类型限定，语法`? super Type`限定为Type地所有超类以及自己

两种限定的区别
超类型限定可以**为方法提供参数，不能使用返回值**。
子类型限定**不可以为方法提供参数，但可以使用返回值**。


#### 通配符捕获
因为通配符不是实际的类型，不是类型变量，所以代码中不能使用`?`。
所以有时候用通过类型变量来捕获通配符所引用的类型。
具体方法是将通配符泛型类型赋值给类型变量泛型类型，从而通过类型变量获得类型。
```java
public static void swapT(Pair<T> p)
{
    //首先用类型变量编写一个方法
}
public static void swap(Pair<?> P){
    //然后编写一个使用通配符泛型类型变量的方法，利用他获得统配符
    //在将变量传递给类型变量泛型类型变量，从而捕获通配符中的类型
    swapT(p);
}
**注意:** 编译器必须能确定通配符表达的是**单一，确定**的类型才能捕获
如：下述情况就不能捕获`ArrayList<Pair<T>> 不能捕获ArrayList<Pari<?>>`



```
