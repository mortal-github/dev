### 约束与局限
类型变量在使用的时候是有限制的。这些限制大多来源于类型檫除
+ **不能用基本类型实例化类型参数**：Object不能保存基本类型值，如果需要可以用包装器代替基本类型。
+ **运行时查询只适用与原始类型**：类型查询只能产生原始类型，千万不要用参数化类型来比较类型。
+ **不能创建参数化类型的数组**：类型檫除后，参数化类型数组将变成原始类型数组。简单来说就是声明的实例化类型与储存的实例化类型可能不匹配
    >所以储存元素的时候，就可能发生类型不匹配问题如
    >```java
    >Pair<Stirng>[] table;
    >table[0] = Pair<Employee>//Pair<String> 与 Pair<Employee>不匹配，但是编译可以通过。故干脆直接禁止参数化类型的数组
    >```
    + 虽然不能创建参数化类型数组，但是可以定义参数化类型数组**变量**。
    + 可以申明通配符类型的数组，然后进行类型转换，但是如果数组元素储存了不匹配的参数化类型对象，就可能发生`ClassCastException`异常
    >```java
    >Pair<String>[] table = (Pair<String>[]) new Pair<?>[10];
    >table[0] = Pair<Employee>; //编译可以通过，但是Pair<String> 与Pair<Employee>不匹配
    >table[0].getFirst();  //这将调用一个String方法，但是Pair<Employee>的该方法放回值是employee,故发生错误！抛出异常
    >```
+ **不能实例化类型变量** 因为类型檫除会让其实例化成了限定类型，这不符合代码逻辑。故不能实例化类型变量
    + 可以通过提供构造器表达式来实例化一个指定类型对象，解决间接实例化类型变量的问题。
    + 或者通过反射调用Class.newInstance。不过**必须先获得Class对象**,如果调用`T.class`将会被檫除成`限定类型.class`不符合代码逻辑
    >```java
    ><T> pair<T> makePair(Class<T> cl){}
    >   cl.newInstance();
    >   //因为Class<U>本身是泛型，所以调用方法时，编译器能推断出类型参数。
    >```
+ **不能构造类型变量数组** 因为类型檫除会导致实例化限定类型的数组，不符合代码逻辑
+ **泛型类的静态上下文中类型变量无效**：不能再静态域或方法中引用类型变量。因为传递给类型变量的类型参数是作用与对象，静态方法与对象无关，静态方法不是对象的方法而是类的方法，显然不可能有具体的实例化类型。
+ **不能抛出或捕获泛型类的实例** 
+ **可以消除对受查异常的检查** 可以在异常规范中使用类型变量，故可以利用泛型消除对受查异常的检查，关键是以下方法
    >```java
    >pubic static <T extends Throwable> void throwsAs(Throwable e) throws T
    >{
    >    throw T e;
    >}
    >//这样子调用方法，编译器将认为是一个非受查异常
    > Block.<RuntimeException>throwAs(t);
    >```
+ **注意檫除后的冲突**

