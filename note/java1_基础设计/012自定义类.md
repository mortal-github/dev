### 自定义类

#### 类定义
>最基本的类定义形式为如下：
```java
modified class ClassName
{
    modified field1
    modified field2
    ...
    modified constructor1
    modified constructor2
    ...
    modified method1
    modified method2
    ...
}
```
1. `class`关键字**声明**一个类，**后跟类名**。
2. 在**声明之后的块**中填写类的**定义**。
3. 类成员：**数据域(fiel1),构造器(constructor),方法(method)**。
4. **修饰符**：修饰类以及成员的属性。
    + **权限属性**：public,private,proteced,default(没有修饰符)
    + **实例属性**：`static`声明类成员**属于类**，不属于对象，没有则表示属于特定实例。
    >属于类的域只有一份，被所有实例共享；属于实例的域不能被别的实例共享。（注意：类域不是实例域，不属于对象状态的值的集合）
    >属于实例的方法不能操作类域，属于类的方法可以操作实例域和类域
    >。(注意：定义属于类的方法目的不是为了操作实例域，所以没有必要操作实例域。操作实例域的方法应该由实例方法来提供，而不是类防范)
    >构造器是用来构造实例，所以构造器只能属于实例。
    + **常量**：`final`关键修饰域(包括实例域和类域)定义常量。
    >对象构造后，实例域必须已经被赋值，且只能被赋值一次。
    >类常量必须在声明后，所有对象被构造器前，被辅助，且只能被赋值一次。
---
#### 源文件
>源文件与类
1. 一个源文件只能定义**一个公有类**。
2. 源文件名必须**与公有类名相同**。
3. 源文件可以有**任意数目的非公有类**。

>多个源文件的使用

若定义了多个类，并使用类多个源文件。且一些类依赖另一些类。
例如：Employee.java,EmployeeTest.java
那么有两种方法编写程序：
+ 通配符编译：`javac Employee*.java`。与通配符匹配的源文件都被编译成类文件。
+ 编译最外层类：`javac EmployeeTest.java`。编译将自动编译源文件中依赖的类的源文件(如果找不到类文件)。

---
#### 构造器
1. 构造器**与类名同名**。
2. 构造器总是伴随**new操作符的执行**被调用。
3. 每个类可以有**一个以上**的构造器。
4. 构造器可以有0个，1个，多个参数。。
5. 构造器**没有返回值**。
```java
class Employee
{
    ...
    //一个以上构造器,与类同名
    public Employee()//零参，无返回值
    {
        ...
    }
    public Employee(String name)//一参，无返回值
    {
        ...
    }
    public Employee(String name, LocalDate hireday)//多参，无返回值
    {
        ...
    }
    ...
    public static void main(String[] args)
    {
        ...
        //伴随new操作符的执行被调用
        new Employee();
        new Employee(name);
        new Employee(name, hireday);
        ..
    }
    ...
}
```
---
#### 隐式参数与显示参数
**实例方法**用于操作**对象**以及存取它们的**数据**。例如
```java
...
private double raise; //实例域
...
public void raiseSalary(double byPrecent)
{
    double raise = salary * byPercent / 100;
    salary += raise;
}
```
故，方法实际上的参数，除了参数列表提供的**显示参数**，还包括**特定实例**的**隐式参数**。
>这个隐式参数标识了方法实际上操作的实例，而不是对所有实例都操作。
**注意**：显然只有实例方法才有隐式参数。

**this关键字**：
在方法中可以使用`this`关键字表示隐式参数。
**建议**：在实例方法中最好显示指出隐式参数，这样可以提高程序的阅读性。
**技巧**：特别地可以定义**与实例域同名的显式参数**，再使用`this`关键字区分实例域与参数，可以使程序**阅读性更高**。
>因为局部变量会屏蔽同名域，所以可用this将同名域区分出来。
```java
public Employee(String name)
{
    this.name = name;
}
//上述代码显然比下述代码阅读性更高
public Employee(String s)
{
    neme = s;
}
```

---
#### 封装
要完成封装，需要提供以下内容：
1. 一个私有的数据域。
2. 一个公有的域访问器方法。
3. 一个公有的域更改器方法。
优势：
1. 可以**改变内部实现**，除了该类的方法，**不会影响其他代码**。
2. 更改器可以执行**错误检查**，远比直接更改数据安全多了。
3. 访问器可以返回**对象域的副本**，**防止**外部代码通过对象引用**直接修改对象域**(使用更改器来修改才安全)。
4. 除此之外，自然还包括了**功能抽象的一般优势**：可以封装复杂的更改过程，降低耦合度，缩小调试范围，提高代码复用率，控制程序复杂性。

**注意：**
+ 访问器返回值如果是**基本类型和不可变对象**，则不需要克隆副本。
+ 如果返回的是**可变对象**的引用，则应该返回**克隆**副本的引用。


---
#### 基于类的访问权限
一个方法可以访问**所属**类的**所有对象**的私有数据。
>也就是说方法可以访问的私有数据**不仅仅只是隐式参数的数据**。
>即，如果再方法参数里传入该类的另一个实例，那么方法可以直接访问该实例的私有数据。
```java
public boolean euqals(Employee other)
{                       //直接访问所属类的其他对象的私有数据。
   return this.name == other.name;
}

```

#### 私有方法
希望设计为私有方法的的情况
+ 将一个计算代码划分为若个辅助方法。（方法之间的次序特调，实现机制非常精密，显然不是适合作为公有接口）

**方法权限与删除限制：**
+ 删除私有方法：改用其他方法实现的时候，就可以删除原有方法。
    >因为类的设计者可以确认，该方法不会被外部的其他类调用。
+ 不可删除公有方法：被的代码可能依赖公有方法，故不能删除。

---
#### final 实例域
`final`关键字

