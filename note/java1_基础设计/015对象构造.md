### 对象构造
由于对象构造，所以java提供了多种编写构造器的机制。
---
#### 重载
**重载**：java允许方法重载，即多个方法拥有**相同的名字**，**不同的参数**，便产生了重载。
**重载解析**：编译器根据重载方法的**参数**与特定方法**调用的所使用的值类型**进行匹配，挑选出相应的重载方法**的过程**称为重载解析。

**重载任何方法**：java允许重载**任何**方法，而不只是构造器方法。
**方法签名**：方法签名包括**方法名**以及**参数类型**。只有方法签名才能完整地描述一个方法。

---
#### 默认域初始化
如果**构造器**中没有**显式地**给**域**赋予初始值，那么域将会被初始为**默认值**。
默认值：
+ 数字：0
+ 布尔：false
+ 对象引用：null

**注意**：局部变量不会默认初始化，要使用局部变量必须显式初始化。这是与域不同的地方。

---

#### 无参构造器
类定义中**如果没有**没有提供构造器，那么系统**将会自动**提供一个**无参构造器**，并将所有域初始化为**默认值**。
类定义中**如果至少提供了一个**构造器，那么系统**不会自动**提供默认构造器。

---
#### 显式域初始化
>通过重载类的构造器，可以采用**多种形式**设置类的实例域的初始状态。
>确保不管怎样调用构造器，每个实例域都可以被设置为一个有意义的处置。**这是一个好的设计习惯**。

+ 在声明中赋值：
    + 在类定义中，直接将一个值赋给任何变量
    + 初始值不一定是常量，可以调用方法对域进行初始。
    >在执行**构造器之前，先进行赋值**操作。
    >当一个类的所有构造器**都希望把相同的值赋予**某个特定的实例域是，这种方式特别有用。
+ 在构造器中赋值

---
#### 参数名
**一个重要规则**：方法的参数变量用同样的名字将实例域屏蔽起来。
>编写构造器(方法同理)时，如果提供了一个与域名相同的变量，
>一定要认识到这是一个局部变量，而不是实例域。
>除非显式指定其为实例域(`this`关键字)。
```java
public Employee(String name)
{
    this.name = name;
}
```
---
调用另一个构造器
`this`关键字的两个用处
+ `this`关键字引用方法的隐式参数。
+  在构造器的**第一个语句**形如`this(...)`将调用同一个类的另一个构造器。
```java
public Employee()
{   ...
    this(name);//调用同一个类，匹配参数的构造器。必须是第一行语句，也只能用在第一行语句。
}
public Employee(String name)
{...}
```

---
#### 初始化块

在一个类的**声明中**，可以包含多个**代码块**。

只要构造类的对象，这些**块就会被执行**。
无论用那个构造器构造对象，首先运行初始化块，然后才运行构造器的主体部分。

**建议：**将初始化块放在域定义之后。
>即使域在初始化块后定义，也可以在初始化块设置域。
>但是为了**避免循环定义**，不要读取初始化块后面的域。

```java
public class Employee{
    private int id;
    {
        id = 1;
    }
    {
        id = 3;
    }

}

```

**静态初始化块：**
可以使用静态初始化块初始化静态域。
关键字`static`声明初始化块为静态初始化块。
```java
static{
    ....
}

```

#### 调用构造器的具体处理步骤
1. 所有数据域被初始化为默认值
2. 按照在类声明中**出现的次序**，依次执行所有域初始化语句和初始化块。
3. 如果构造器第一行调用了第二个构造器，则调用第二个构造器。
4. 执行这个构造器。


#### 对象析构与fnalize方法
**析构器**：有写面向对象语言有显示的析构器方法，其中放置一些当对象不再使用时需要执行的清理代码。常见操作是回收分配给对象的储存空间。
**java的垃圾回收器**：java有自动的垃圾回收器，不需要人工回收内存，所以java不支持析构器。

**`finalize`方法**：可以为**任何一个类**提供一个`finalize`方法。
>`finalize`方法在垃圾回收器清除对象之前调用。
>实际应用中，不要依赖于`finalize`方法回收资源，因为无法确定这个方法何时调用。

**确保类关闭前调用finalizer**
+ `System.runFinalizersOnExit(true)`可以确保finalize方法在java关闭前被调用。**不过这个方法不安全**。
+ 代替方法：`Runtime.addShutdownHook`添加关闭钩。

**`close`方法人工管理资源**
如果某个资源需要在使用完毕后**立刻被关闭**。就需要人工管理。
`close`方法清理资源。
