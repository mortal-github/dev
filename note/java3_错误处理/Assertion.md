### 断言
断言：断言机制允许在测试期间插入一些代码，当代码发布的时候**自动移除这些测试代码**。
>测试：在测试期间往往需要测试某些条件的状态，但是这种测试不是为了分支转移，
>而是为了验证条件在处理前中后的状态否是符合要求。这些代码不是程序逻辑必要的。

#### 断言语法
+ 关键字`assert`关键提供断言,有两种形式
```java
assert 条件；
assert 条件 : 表达式;   //表达式只是用来构造消息字符串，并不会储存值。
```
+ 断言过程
    + 两种形式都检查条件，如果结果为false，则抛出`AssertionError`异常
    + 第二种形式将表达式传入构造器，转换成消息字符串。
> 表达式的目的只是产生消息字符串，原因是为了阻止程序员尝试从断言中回复程序运行。这不符合断言的初衷。

#### 启用和禁用断言
**默认情况，断崖被禁用.**
启用和禁用断言**不需要重新编译程序**。
>启用和禁用断言是类加载器的任务。
>禁用断言时，类加载器**跳过断言代码**。

可以在启动程序程序时向java实用程序传入运行选项启动断言。

##### 启用禁用非系统类断言
+ `-enableassertions`或`-ea` 选项可启用断言.
+ `disableassertions`或`-da` 选项禁用断言。
+ 可以在某个类或整个包(包括子包中类)中使用断言：`-ea:MyClass -ea:com.pacakage...`
```java
//启动断言
java -enableassertions MyApp    
java -ea MyApp
//禁用断崖
java -disableassertions MyApp
java -da MyApp
//在某个类或整个包(包括子包)的启动或禁用断言
java -ea:MyClass -ea:com.mycompany.mylib... MyApp
java -ea:... -da:MyClass App
```

##### 启用禁用系统类断言
-ea和-da开不能应用没有类加载器的“系统类”
需要用`-enablesystemassertions/-ea`开关启用禁用断言

##### 在程序中控制类加载器的断言状态
可以在程序中控制类加载其的断言状态
请记住这**仅影响更改之后装入的类**。在大多数情况下，您会发现您是从命令行启用断言。
```java
java.lang.ClassLoader
+ void setDefaultAssertionStatus(boolean b)
//对于通过该来类加载器的所有类，如果没有显式说明类或包的断言状态，就启用或禁用断言。

+ void setClassAssertionStatus(String className, boolean b)
//对于给定的类和他的内部类，启用或禁用断言

+ void setPackageAssertionStatus(String packageName, boolean b)
//对于特定的包及其子包中的所有类，启用或禁用断言

+ void clearAssertionStatus()
//移去所有类或包的显示断言状态设置，并禁用通过该类加载器加载的类断言。

```

#### 使用断言完成参数检查
使用断言的情况
+ 断言失败时致命的，不可恢复的错误。
+ 断言检查只用于开发和测试阶段。

例如：前置条件检查。
>前置条件值得是传入一个方法的参数应该在传入前就应该满足的条件
>例如除法运算，方法要求传入的除数不为0，那么如果传入除数为0就会发生不可预料的情况。
>该方法之所以不对参数进行检查可能是因为其认为一定会被正确使用
>但是是否正确使用需要由方法的调用者来确定，所以测试阶段需要测方法的待用者是否正确使用方法，因而需要通过断言来测试方法是否被正确调用。
>显然这个测试条件是为了编码是修正逻辑用的，一旦逻辑修改就意味检查是一定通过，所以发布的时候不需要再测试。
>故而使用断言比较合适。
```java
 double divide(double n1, double n2)
 {
     assert n2>0 : n2>0;
     return n1/n2;
 }

```

#### 为文档假设使用断言
```java
if(i % 3 == 0){}
else if(i %3 == 1) {}
else {//显然此处假设i%3 == 2,此时可以再此处使用断言
assert i%3==2;  //这样做可以清楚地表达出假设条件。
} 
```
